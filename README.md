# java_Architecture_example

`RMI 클라이언트 서버`

실행 순서:
1. RMI 레지스트리에서 "Hello"라는 이름으로 바인딩된 객체를 찾습니다.
2. 찾은 객체를 Hello 인터페이스의 스텁으로 캐스팅합니다.
3. sayHello() 메서드를 호출하여 서버의 응답을 받습니다.
4. "서버 응답: 안녕하세요, RMI!"라는 메시지가 출력됩니다.

전체 실행 과정
1. 서버 실행:
서버 코드를 컴파일하고 실행합니다.
서버가 시작되면 RMI 레지스트리에 객체가 바인딩됩니다.

2. 클라이언트 실행:
클라이언트 코드를 컴파일하고 실행합니다.
클라이언트는 서버에 연결하고, sayHello() 메서드를 호출하여 서버의 응답을 출력합니다.

---

`파이프 앤 필터(Pipe and Filter)` 아키텍처
소프트웨어 설계 패턴 중 하나로, 데이터 처리를 독립적인 구성 요소(필터)로 나누고 이들 간에 데이터를 흐르게 하는 방식입니다. 이 패턴은 데이터 흐름을 명확하게 하고, 각 필터를 독립적으로 개발하고 테스트할 수 있는 장점을 제공

개념
- 필터(Filter): 데이터를 처리하는 독립적인 컴포넌트입니다. 각 필터는 입력을 받아 처리한 후 결과를 출력합니다. 필터는 상태를 갖지 않으며, 입력에 대해 항상 동일한 출력을 제공합니다(순수 함수).
- 파이프(Pipe): 필터 간에 데이터를 전달하는 경로입니다. 필터의 출력은 다음 필터의 입력으로 연결됩니다. 파이프는 데이터 흐름을 관리하고, 각 필터 간의 결합도를 낮춥니다.
- 데이터 흐름: 데이터는 파이프를 통해 필터 간에 순차적으로 흐릅니다. 각 필터는 자신의 작업을 수행한 후 결과를 다음 필터에 전달합니다.

클래스
Client: 필터와 파이프를 설정하고 데이터를 전송하는 역할을 합니다.
Pipe: 데이터를 필터 간에 전송하는 역할을 하며, 여러 필터를 연결할 수 있습니다.
Filter: 실제 데이터 처리를 수행합니다. 여러 개의 필터가 연결되어 다양한 처리를 수행할 수 있습니다.

---

`EventBus`

주요 개념
- 이벤트(Event): 시스템에서 발생하는 특정한 상태 변화나 사실을 나타내는 객체입니다. 예를 들어, 사용자 입력, 시스템 상태 변화, 외부 API 호출 등이 이벤트로 표현될 수 있습니다.
- 리스너(Listener): 특정 이벤트에 대한 반응으로 동작하는 구성 요소입니다. 리스너는 이벤트가 발생할 때 호출되어, 해당 이벤트를 처리하는 로직을 포함합니다.
- 이벤트 버스(Event Bus): 이벤트를 발행(publish)하고 구독(subscribe)하는 중앙 허브 역할을 합니다. 이벤트 버스는 리스너를 등록하고, 발생한 이벤트를 해당 리스너에게 전달합니다.

아키텍처 구성 요소
- 발행자(Publisher): 이벤트를 생성하고 이벤트 버스에 발행하는 구성 요소입니다. 발행자는 이벤트가 발생할 때마다 이벤트 버스에 해당 이벤트를 전달합니다.
- 구독자(Subscriber): 특정 이벤트에 관심을 갖고 이를 수신하는 구성 요소입니다. 구독자는 이벤트 버스에 자신을 등록하여, 특정 이벤트가 발생할 때마다 통지를 받습니다.
- 이벤트 버스: 발행자와 구독자 간의 중재자 역할을 하며, 이벤트를 수집하고 적절한 구독자에게 전달합니다.

동작 방식
- 구독: 구독자는 이벤트 버스에 특정 이벤트를 구독합니다. 이벤트 버스는 구독자의 참조를 저장합니다.
- 발행: 발행자는 이벤트가 발생하면 이벤트 버스에 해당 이벤트를 발행합니다.
- 전파: 이벤트 버스는 발행된 이벤트를 수신하고, 이를 구독자에게 전달합니다. 각 구독자는 자신이 구독한 이벤트에 대해 정의된 처리 로직을 수행합니다.
